<html>
	<head>
		<title>WebGL text</title>
		<script src="glMatrix-0.9.5.min.js"></script>
		<script src="text.js"></script>
		<script src="jquery-1.11.1.min.js"></script>
	</head>
	
	<body onload="startupDraw()">
		<canvas id="textureCanvas" style="border: 1px solid #000; display: none">I'm sorry your browser does not support the HTML5 canvas element.</canvas>
		<canvas id="webglCanvas" style="border: 1px solid #000;" width="768" height="768"></canvas>
	</body>
	
	<script>
		var startupDraw = function () {	
			var canvas = document.getElementById("webglCanvas");
			initWebGL(canvas);
			initGLText("Verdana");
			draw();
			setInterval( function () { draw(); }, 20);			
		};
		
		function initWebGL(canvas) {
			initGL(canvas);
			initBuffers();
			initShaders();
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.disable(gl.DEPTH_TEST);
		}
			
		var myFragmentShaderTextSrc =	
			"precision mediump float; " + 
			"varying vec2 vTextureCoord; " +
			"uniform sampler2D uSampler; " +
			"" + 
			"uniform float time; " + 
			"varying float xx; " + 
			"varying float yy; " + 
			"uniform float va; " + 
			"uniform float vb; " + 
			"uniform float vc; " + 
			"uniform float vd; " + 
			"vec3 veccos(in vec3 a) { return vec3(cos(a.x), cos(a.y), cos(a.z)); } " + 
			"vec3 vecsin(in vec3 a) { return vec3(sin(a.x), sin(a.y), sin(a.z)); } " + 
			"vec3 vectan(in vec3 a) { return vec3(tan(a.x), tan(a.y), tan(a.z)); } " + 
			"vec3 vecabs(in vec3 a) { return vec3(abs(a.x), abs(a.y), abs(a.z)); } " + 
			"vec3 vecsqr(in vec3 a) { return vec3(a.x * a.x, a.y * a.y, a.z * a.z); } " + 
			"vec3 vecadd(in vec3 a, in vec3 b) { return vec3(a.x + b.x, a.y + b.y, a.z + b.z); } " + 
			"vec3 vecsubstract(in vec3 a, in vec3 b) { return vec3(a.x - b.x, a.y - b.y, a.z - b.z); } " + 
			"vec3 vecmultiply(in vec3 a, in vec3 b) { return vec3(a.x * b.x, a.y * b.y, a.z * b.z); } " + 
			"vec3 vecdiv(in vec3 a, in vec3 b) { return vec3(a.x / b.x, a.y / b.y, a.z / b.z); } " + 
			"vec3 createvector(in float a, in float b, in float c) { return vec3(a, b, c); } " + 
			"vec3 veccolormap(in vec3 a, in vec3 b, in vec3 c) { return createvector(a.x / 10.0, b.x / 10.0, c.x / 10.0); } " + 			
			"" + 
			"void main(void) { " + 
			"   vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)); " + 
			"	if (textureColor.r < 0.6) {" + 
			"		float x = xx * 10.0, y = yy * 10.0;" + 
			"		vec3 v = VALUE; " + 
			"" + 
		/*	"		float fillBorder = 0.0; " + 
			"		if (texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).r > 0.0) fillBorder = 1.0; " + 
			"		if (fillBorder < 0.2) " + 
			" 			gl_FragColor = vec4(v.x, v.y, v.z, 1.0); " + 
			"		else " + 
			" 			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); " + 
			"	} " + 
			*/
			"		if (textureColor.r + textureColor.g + textureColor.b < 0.6) " + 
			" 			gl_FragColor = vec4(v.x, v.y, v.z, 1.0); " + 
			"		else {" + 
			"		vec4 vb = vec4(VALUEBORDER, 1.0); " + 
			" 		gl_FragColor = vb; }" + 
			"	} " +  
			" 	else " + 
			"		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);" + 
			"}" ;
	
		var myVertexShaderSrc =  		
			"attribute vec3 aVertexPosition; " + 
			"attribute vec2 aTextureCoord; " + 
			"uniform mat4 uMVMatrix; " + 
			"uniform mat4 uPMatrix; " + 
			"uniform mat3 uNMatrix; " + 
			"varying vec2 vTextureCoord; " + 
			"varying float xx, yy; " + 
			"" + 
			"void main(void) { " + 
			"	gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); " + 
			"	vTextureCoord = aTextureCoord; " + 
			"	xx = clamp(aVertexPosition.x,0.0,1.0); " + 
			"	yy = clamp(aVertexPosition.y,0.0,1.0); " + 
			"}";
		
		function initGL(canvas) {
			try {
				gl = canvas.getContext("experimental-webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			}
			catch (e) {
			}
			if (!gl) {
				alert("Could not initialise WebGL");
			}
		}

		function initBuffers() {
			squareVertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
			vertices = [
				 1.0,  1.0,  0.0,
				 0.0,  1.0,  0.0,
				 1.0,  0.0,  0.0,
				 0.0,  0.0,  0.0
			];				
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			squareVertexPositionBuffer.itemSize = 3;
			squareVertexPositionBuffer.numItems = 4;		
		}
		
		var globalScale = 10.0;
		var globalXRef = 0.0;
		var globalYRef = 0.0;
		var indexTexture = 0;
		var indexFont = 0;
		var entities = 
			["vecdiv(vecsin(createvector(0.6607,0.3364,0.4570)),vecadd(vecabs(vecsubstract(vecsin(vecsin(createvector(x,y,y))),veccos(vecabs(vecabs(createvector(y,x,x)))))),vecabs(vecabs(vecsin(createvector(x,y,y))))))",
			 "vecmultiply(createvector(y,0.3843,0.1653),vecadd(veccos(vecsqr(vecadd(vecadd(createvector(y,y,x),vecsqr(veccos(createvector(x,x,y)))),vecsqr(vectan(createvector(x,x,x)))))),vectan(vectan(vecmultiply(vecsin(createvector(x,y,y)),vecsin(vecabs(createvector(y,x,x))))))))",
			 "vecsin(vecadd(vecsin(vectan(vectan(vecmultiply(vecsin(createvector(x,y,y)),veccos(vecabs(createvector(y,x,x))))))),createvector(0.9249,0.3733,0.7626)))",
			 "vecadd(vecmultiply(vecmultiply(veccos(createvector(x,y,y)),vecsin(vectan(createvector(y,y,x)))),vecsin(vecsin(vectan(createvector(0.4360,x,x))))),vecsin(veccolormap(createvector(x,0.1213,0.3265),createvector(x,y,0.1465),createvector(0.6646,0.6055,x))))",
			 "vecdiv(vecsin(createvector(time,y,0.2655)),vecadd(vecabs(vecsubstract(vecsin(createvector(x,time,0.3301)),veccos(vecabs(vecabs(createvector(y,x,x)))))),vecabs(vecabs(vecsin(createvector(x,y,y))))))"
			 ];
		var entityBorder = "vec3(1.0, 0.0, 0.0)";
		
		function initShaders() {
			var entities = 
				["vecdiv(vecsin(createvector(0.6607,0.3364,0.4570)),vecadd(vecabs(vecsubstract(vecsin(vecsin(createvector(x,y,y))),veccos(vecabs(vecabs(createvector(y,x,x)))))),vecabs(vecabs(vecsin(createvector(x,y,y))))))",
				 "vecmultiply(createvector(y,0.3843,0.1653),vecadd(veccos(vecsqr(vecadd(vecadd(createvector(y,y,x),vecsqr(veccos(createvector(x,x,y)))),vecsqr(vectan(createvector(x,x,x)))))),vectan(vectan(vecmultiply(vecsin(createvector(x,y,y)),vecsin(vecabs(createvector(y,x,x))))))))",
				 "vecsin(vecadd(vecsin(vectan(vectan(vecmultiply(vecsin(createvector(x,y,y)),veccos(vecabs(createvector(y,x,x))))))),createvector(0.9249,0.3733,0.7626)))",
				 "vecadd(vecmultiply(vecmultiply(veccos(createvector(x,y,y)),vecsin(vectan(createvector(y,y,x)))),vecsin(vecsin(vectan(createvector(0.4360,x,x))))),vecsin(veccolormap(createvector(x,0.1213,0.3265),createvector(x,y,0.1465),createvector(0.6646,0.6055,x))))",
				 "vecdiv(vecsin(createvector(time,y,0.2655)),vecadd(vecabs(vecsubstract(vecsin(createvector(x,time,0.3301)),veccos(vecabs(vecabs(createvector(y,x,x)))))),vecabs(vecabs(vecsin(createvector(x,y,y))))))"
				 ];

			var result = myFragmentShaderTextSrc;
			var entity = entities[Math.abs(indexTexture) % entities.length];
			result = result.replace("VALUESCALE", globalScale.toFixed(2).toString());
			result = result.replace("VALUEXREF", globalXRef.toFixed(2).toString());
			result = result.replace("VALUEYREF", globalYRef.toFixed(2).toString());
			result = result.replace("VALUE", entity.toLowerCase());
			result = result.replace("VALUEBORDER", entityBorder.toLowerCase());
		
			var vertexShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vertexShader, myVertexShaderSrc);
			gl.compileShader(vertexShader);
			var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fragmentShader, result);
			gl.compileShader(fragmentShader);
			shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				console.log("Could not initialise shaders.");
			}

			gl.useProgram(shaderProgram);
			shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
			shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
			gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
			shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
			shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
			shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
			shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
		}
		
		var globalStartTime = 0.0;
		var globalTime = 0.0, globalVa = 0.0, globalVb = 0.0, globalVc = 0.0, globalVd = 0.0;
		var deltaTime = 0.1;

		function resetTimer() {
			globalStartTime = Date.now();
		}

		function timerValue() {
			return (Date.now() - globalStartTime) / 1000.0;
		}

		var testa = 0.0;
		function draw () { 
			var textLines = 20, textColumns = 20;
			
			// Set blend mode for drawing text
			gl.enable(gl.BLEND);
			gl.blendEquation(gl.FUNC_ADD);
			gl.blendFunc(gl.ONE_MINUS_CONSTANT_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			
			// Prepare to draw text
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			mat4.identity(pMatrix);
			mat4.ortho(0, textLines, 0, textColumns, 0.1, 100.0, pMatrix);
			mat4.identity(mvMatrix);
			mat4.translate(mvMatrix, [0.0, 0.0, -1.0]);
			
			globalVa = timerValue();
			var location = gl.getUniformLocation(shaderProgram, "va");
			gl.uniform1f(location, globalVa);	
			location = gl.getUniformLocation(shaderProgram, "vb");
			gl.uniform1f(location, globalVb);	
			location = gl.getUniformLocation(shaderProgram, "vc");
			gl.uniform1f(location, globalVc);	
			location = gl.getUniformLocation(shaderProgram, "vd");
			gl.uniform1f(location, globalVd);
			location = gl.getUniformLocation(shaderProgram, "time");
			gl.uniform1f(location, timerValue());
	
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			gl.activeTexture(gl.TEXTURE0);
			
			// Draw text
			drawText("PVM is back sucker!", 0.5, 2.0 + testa, 1.0);
		//	testa+=0.05;
		}	

		function changeData(data) {
			var result = [];
			result.push(data[1]);
			result.push(data[2]);
			return result;
		}

		function mutateTexture () {
			$.ajax({
				type : 'GET',
				url : "/messageGetWithCriteria",
				data : { language: "rgb-color-images-vector", c: "entity-rgb" },
				dataType : "text",
				success : function(data) {
					var result = data.split("|");
					result = changeData(result);
					entities[entities.length] = result[1];
					indexTexture = entities.length-1;
					initShaders();
				},
				error : function(data) {
					console.log('Call failed');
				}
			});
		}
		
		function mutateBorderTexture () {
			$.ajax({
				type : 'GET',
				url : "/messageGetWithCriteria",
				data : { language: "rgb-color-images-vector", c: "entity-rgb" },
				dataType : "text",
				success : function(data) {
					var result = data.split("|");
					result = changeData(result);
					entityBorder = result[1];
					initShaders();
				},
				error : function(data) {
					console.log('Call failed');
				}
			});
		}
		
		function handleKeyDown(event) {
			if (event.keyCode == 38) indexTexture++;
			if (event.keyCode == 40) indexTexture--;
			if (event.keyCode == 39) mutateTexture();
			if (event.keyCode == 37) mutateBorderTexture();
			initShaders();
		}
		
		window.onkeydown = handleKeyDown;		
		resetTimer();
	</script>
</html>